{"title":"How to prevent calling api twice when using Angular Universal?","description":"Usage example of TransferState","keywords":["Angular","Angular Universal","Http","SSR","Server Side Rendering","twice","api"],"tags":["Angular2+","Javascript","Typescript","SSR"],"banner":"/assets/images/posts/2/banner.png","thumbnail":"/assets/images/posts/2/thumbnail.png","bannerCredit":{"name":"Gabriel Heinzer","id":"@6heinz3r"},"publish":"2022-02-20 00:00:00","id":"2","contents":"The Angular provides powerful support for Server-Side Rendering with Angular Universal.\r\nBut when getting some data via HTTP Client, I noticed that\r\nthe page calls API twice from the server and browser.\r\nThis is the solution to prevent this weirdness.\r\n\r\n# Prerequisite\r\n\r\n- Angular2+. I used Angular 13.2.0\r\n- Angular Universal. I used `@nguniversal/express-engine^13.0.2`.\r\n\r\n# The situation\r\n\r\n```typescript\r\n@Component({\r\n  selector: 'app-get-data',\r\n  templateUrl: './get-data.component.html',\r\n  styleUrls: ['./get-data.component.scss'],\r\n})\r\nexport class GetDataComponent implements OnInit {\r\n  loading = false;\r\n\r\n  constructor(\r\n    private http: HttpClient,\r\n  ) {\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    const sub = this.http.get('{endpoint-to-get-data}')\r\n      .pipe(finalize(() => this.loading = false))\r\n      .subscribe({\r\n        error: err => console.error(err),\r\n      });\r\n\r\n    this.loading = true;\r\n  }\r\n}\r\n```\r\n\r\nImagine that you have the code to get some data by calling API endpoint like above.\r\nIf you're not using Angular Universal, the above code doesn't make any issue.\r\nAfter the component initialized, the `loading` will be `true` until the calling API finished.\r\n\r\nBut if the Angular Universal is used,\r\nthe user may see the completed page for a short time at first,\r\nthen will encounter the loading indicator for fetching data again.\r\n\r\n# Why it happens?\r\n\r\nThe Angular is really clever framework and so does Angular Universal.\r\nIf there are some API calls when loading the page via server,\r\nthe Angular waits until the calling API finished to show completed page.\r\n\r\nAt that time, the Angular walk through the LifeCycle hooks\r\nfrom `ngOnInit()` to `ngOnDestory()` to create static HTML markups.\r\nAfter the page loaded, the Angular calls the LifeCycle hooks again\r\nto make the component's functions to be functional.\r\n\r\nSince these works create different instances,\r\nthe properties will not be shared.\r\n\r\n# To solve it ..\r\n\r\nThe solution is simple.\r\nJust let Angular know if page is loaded via server or via browser.\r\nTo do this, the Angular provides `TransferState`.\r\n\r\n# TransferState\r\n\r\nThe `TransferState` is similar with `LocalStorage`.\r\nBut it makes you to keep state between server and browser.\r\n\r\n## Add required modules\r\n\r\nBefore using `TransferState` from your component,\r\nyou need to import `BrowserTransferStateModule` and `ServerTransferStateModule`\r\nto the `app.module.ts` and `app.server.module.ts`.\r\n\r\n```typescript\r\n// app.module.ts\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent\r\n  ],\r\n  imports: [\r\n    BrowserModule.withServerTransition({appId: 'serverApp'}),\r\n    // Import `BrowserTransferStateModule`\r\n    BrowserTransferStateModule,\r\n    AppRoutingModule,\r\n    HttpClientModule,\r\n  ],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule {\r\n}\r\n```\r\n\r\n```typescript\r\n// app.server.module.ts\r\n@NgModule({\r\n  imports: [\r\n    AppModule,\r\n    ServerModule,\r\n    // Import `ServerTransferStateModule`\r\n    ServerTransferStateModule,\r\n  ],\r\n  bootstrap: [AppComponent],\r\n})\r\nexport class AppServerModule {\r\n}\r\n```\r\n\r\n## Inject TransferState\r\n\r\nNext, inject the `TransferState` to your component.\r\n\r\n```typescript\r\n@Component({\r\n  selector: 'app-get-data',\r\n  templateUrl: './get-data.component.html',\r\n  styleUrls: ['./get-data.component.scss'],\r\n})\r\nexport class GetDataComponent implements OnInit {\r\n  loading = false;\r\n\r\n  constructor(\r\n    private http: HttpClient,\r\n    // Inject `TransferState`.\r\n    private transferState: TransferState,\r\n  ) {\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    const sub = this.http.get('{endpoint-to-get-data}')\r\n      .pipe(finalize(() => this.loading = false))\r\n      .subscribe({\r\n        error: err => console.error(err),\r\n      });\r\n\r\n    this.loading = true;\r\n  }\r\n}\r\n```\r\n\r\nYou can use following methods for `TransferState`.\r\nThese methods are similar with methods of `localStraoge`.\r\n\r\n- `set<T>(key: StateKey<T>, value: T): void`.\r\n- `get<T>(key: StateKey<T>, defaultValue: T): T`.\r\n- `remove<T>(key: StateKey<T>): void`.\r\n\r\nTo see full documentation, check here: [TransferState](https://angular.io/api/platform-browser/TransferState).\r\n\r\n## Create key and get/set state\r\n\r\nThen create the `StateKey` with `makeStateKey()` function.\r\n\r\n```typescript\r\nconst key = makeStateKey('some-key-name');\r\n```\r\n\r\nYou can use this key to set and get data from the `TransferState` like below.\r\n\r\n```typescript\r\n@Component({\r\n  selector: 'app-get-data',\r\n  templateUrl: './get-data.component.html',\r\n  styleUrls: ['./get-data.component.scss'],\r\n})\r\nexport class GetDataComponent implements OnInit {\r\n  loading = false;\r\n\r\n  // Create the key for data which should be shared between server and browser.\r\n  private _key = makeStateKey('data-loaded-state');\r\n\r\n  constructor(\r\n    private http: HttpClient,\r\n    private transferState: TransferState,\r\n  ) {\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    // Call the API endpoint when data loaded state is not `true`\r\n    if (!this.transferState.get<boolean>(this._key, false)) {\r\n      const sub = this.http.get('{endpoint-to-get-data}')\r\n        .pipe(finalize(() => {\r\n          this.loading = false;\r\n\r\n          // When the API call ended,\r\n          // Set data loaded state as `true` to prevent the browser's API call.\r\n          this.transferState.set<boolean>(this._key, true);\r\n        }))\r\n        .subscribe({\r\n          error: err => console.error(err),\r\n        });\r\n\r\n      this.loading = true;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNow you don't see the duplicated API calls after the server responded.\r\nBut it's not the end.\r\nThe component can be destroyed and created again by the browser.\r\nIn this case, it won't call the API again because the `data-loaded-state` is still `true`.\r\n\r\nYou need to remove the data in key like below when the component to be destroyed.\r\n\r\n```typescript\r\n@Component({\r\n  selector: 'app-get-data',\r\n  templateUrl: './get-data.component.html',\r\n  styleUrls: ['./get-data.component.scss'],\r\n})\r\nexport class GetDataComponent implements OnInit, OnDestroy {\r\n  loading = false;\r\n\r\n  private _key = makeStateKey('data-loaded-state');\r\n\r\n  constructor(\r\n    private http: HttpClient,\r\n    private transferState: TransferState,\r\n  ) {\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    if (!this.transferState.get<boolean>(this._key, false)) {\r\n      const sub = this.http.get('{endpoint-to-get-data}')\r\n        .pipe(finalize(() => {\r\n          this.loading = false;\r\n\r\n          this.transferState.set<boolean>(this._key, true);\r\n        }))\r\n        .subscribe({\r\n          error: err => console.error(err),\r\n        });\r\n\r\n      this.loading = true;\r\n    }\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    // Remove the key.\r\n    this.transferState.remove<boolean>(this._key);\r\n  }\r\n}\r\n```\r\n\r\nThen everything works well.\r\n\r\n# Conclusion\r\n\r\nBecause it shows just example, I used the loaded state to prevent calling API.\r\nBut you can set any data in `TransferState`, like the response of API call.\r\nIt means you can render initial state of the component from the server side.\r\n\r\nHope the Angular gets more popular than React or other frameworks üòÅ\r\n","created":"2022-02-20 00:00:00"}